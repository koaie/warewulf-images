name: Build warewulf images
run-name: ${{ gitea.actor }} Building warewulf images
on:
  push:
    branches:
      - main # Assuming 'main' is the default branch
  workflow_dispatch:
    inputs:
      build_type:
        description: 'Type of build to perform'
        required: true
        default: 'incremental'
        type: choice
        options:
          - 'full'
          - 'incremental'
      image_type:
        description: 'Limit build to specific image type'
        required: true
        default: 'all'
        type: choice
        options:
          - 'all'
          - 'debian'
          - 'rocky'
          - 'slurm'

jobs:
  full-rebuild:
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.build_type == 'full'
    runs-on: carp
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4

      - name: Log in to continer registry
        uses: redhat-actions/podman-login@v1
        with:
          username: ${{ gitea.actor }}
          password: ${{ secrets.PASSWORD }}
          registry: ${{ vars.REPO_BASE }}
          auth_file_path: /run/user/1000/containers/auth.json

      - name: Find, Build, and Push All Containers
        run: |
          set -e # Exit immediately if a command fails
          
          # Set the base URL for your Gitea registry
          # Gitea variables like instance_url and owner are already lowercase
          REGISTRY_BASE="${{ vars.REPO_BASE }}/${{ gitea.repository_owner }}"
          
          # Get a lowercase version of the repo name for the root case
          REPO_NAME_LOWER=$(echo "${{ gitea.repository_name }}" | tr '[:upper:]' '[:lower:]')
          
          echo "Registry base URL: $REGISTRY_BASE"

          # Determine the base path filter
          BUILD_PATH_FILTER=""
          if [[ -n "${{ github.event.inputs.build_path }}" ]]; then
              BUILD_PATH_FILTER="./${{ github.event.inputs.build_path }}"
          elif [[ "${{ github.event.inputs.image_type }}" != "all" ]]; then
              BUILD_PATH_FILTER="./${{ github.event.inputs.image_type }}"
          fi

          if [[ -n "$BUILD_PATH_FILTER" ]]; then
              echo "Filtering builds to: $BUILD_PATH_FILTER"
              # Find all files named 'Containerfile' and loop through them, filtered by path
              find "$BUILD_PATH_FILTER" -name Containerfile | awk -F/ '{ print NF, $0 }' | sort -n | cut -d' ' -f2- | while read -r cfile; do
                  # Remove the leading './' for cleaner names
                  cfile_clean=$(echo "$cfile" | sed 's|^\./||') # e.g., rocky/vm/Containerfile
                  
                  # Get the directory of the Containerfile (this is the build context)
                  context_dir=$(dirname "$cfile_clean") # e.g., rocky/vm or .
                  
                  image_name=""
                  image_tag=""

                  # Check if this is the root Containerfile
                  if [ "$context_dir" = "." ]; then
                      image_name="$REPO_NAME_LOWER"
                      image_tag="latest"
                  else
                      # This is in a subdirectory
                      current_dir_name=$(basename "$context_dir") # e.g., vm or debian
                      parent_dir_path=$(dirname "$context_dir") # e.g., rocky or .

                      if [ "$parent_dir_path" = "." ]; then
                          # Top-level dir (e.g., debian/Containerfile)
                          # Image name is the dir name, tag is latest
                          image_name=$(echo "$current_dir_name" | tr '[:upper:]' '[:lower:]')
                          image_tag="latest"
                      else
                          # Sub-level dir (e.g., rocky/vm/Containerfile)
                          # Image name is parent dir, tag is current dir
                          image_name=$(echo "$(basename "$parent_dir_path")" | tr '[:upper:]' '[:lower:]')
                          image_tag=$(echo "$current_dir_name" | tr '[:upper:]' '[:lower:]')
                      fi
                  fi
                  
                  # This is the full URL for the registry (e.g., gitea.example.com/owner/rocky:vm)
                  IMAGE_URL="${REGISTRY_BASE}/${image_name}:${image_tag}"
                  echo ""
                  echo "================================================="
                  echo "Found:      $cfile_clean"
                  echo "Context:    $context_dir"
                  echo "Building:   $IMAGE_URL"
                  echo "================================================="
                  
                  # Build the image and tag it with the full registry URL
                  podman build --no-cache -t "$IMAGE_URL" -f "$cfile_clean" "$context_dir"
                  
                  echo "Pushing $IMAGE_URL"
                  podman push "$IMAGE_URL"
                  echo "================================================="
                  echo ""
              done
          else
              echo "Building all image types."
              # Find all files named 'Containerfile' and loop through them (no filter)
              find . -name Containerfile | awk -F/ '{ print NF, $0 }' | sort -n | cut -d' ' -f2- | while read -r cfile; do
                  # Remove the leading './' for cleaner names
                  cfile_clean=$(echo "$cfile" | sed 's|^\./||') # e.g., rocky/vm/Containerfile
                  
                  # Get the directory of the Containerfile (this is the build context)
                  context_dir=$(dirname "$cfile_clean") # e.g., rocky/vm or .
                  
                  image_name=""
                  image_tag=""

                  # Check if this is the root Containerfile
                  if [ "$context_dir" = "." ]; then
                      image_name="$REPO_NAME_LOWER"
                      image_tag="latest"
                  else
                      # This is in a subdirectory
                      current_dir_name=$(basename "$context_dir") # e.g., vm or debian
                      parent_dir_path=$(dirname "$context_dir") # e.g., rocky or .

                      if [ "$parent_dir_path" = "." ]; then
                          # Top-level dir (e.g., debian/Containerfile)
                          # Image name is the dir name, tag is latest
                          image_name=$(echo "$current_dir_name" | tr '[:upper:]' '[:lower:]')
                          image_tag="latest"
                      else
                          # Sub-level dir (e.g., rocky/vm/Containerfile)
                          # Image name is parent dir, tag is current dir
                          image_name=$(echo "$(basename "$parent_dir_path")" | tr '[:upper:]' '[:lower:]')
                          image_tag=$(echo "$current_dir_name" | tr '[:upper:]' '[:lower:]')
                      fi
                  fi
                  
                  # This is the full URL for the registry (e.g., gitea.example.com/owner/rocky:vm)
                  IMAGE_URL="${REGISTRY_BASE}/${image_name}:${image_tag}"
                  echo ""
                  echo "================================================="
                  echo "Found:      $cfile_clean"
                  echo "Context:    $context_dir"
                  echo "Building:   $IMAGE_URL"
                  echo "================================================="
                  
                  # Build the image and tag it with the full registry URL
                  podman build --no-cache -t "$IMAGE_URL" -f "$cfile_clean" "$context_dir"
                  
                  echo "Pushing $IMAGE_URL"
                  podman push "$IMAGE_URL"
                  echo "================================================="
                  echo ""
              done
          fi
          
          echo "All builds complete."

  incremental-build:
    if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.build_type == 'incremental')
    runs-on: carp
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4

      - name: Log in to continer registry
        uses: redhat-actions/podman-login@v1
        with:
          username: ${{ gitea.actor }}
          password: ${{ secrets.PASSWORD }}
          registry: ${{ vars.REPO_BASE }}
          auth_file_path: /run/user/1000/containers/auth.json

      - name: Incremental Build and Push Containers
        run: |
          set -e
          REGISTRY_BASE="${{ vars.REPO_BASE }}/${{ gitea.repository_owner }}"
          REPO_NAME_LOWER=$(echo "${{ gitea.repository_name }}" | tr '[:upper:]' '[:lower:]')
          echo "Registry base URL: $REGISTRY_BASE"

          declare -A build_contexts

          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
              echo "Manual incremental build triggered."
              
              BUILD_PATH_FILTER="."
              if [[ -n "${{ github.event.inputs.build_path }}" ]]; then
                  BUILD_PATH_FILTER="./${{ github.event.inputs.build_path }}"
              elif [[ "${{ github.event.inputs.image_type }}" != "all" ]]; then
                  BUILD_PATH_FILTER="./${{ github.event.inputs.image_type }}"
              fi

              echo "Searching for Containerfiles in: $BUILD_PATH_FILTER"
              for cfile in $(find "$BUILD_PATH_FILTER" -name Containerfile); do
                  cfile_clean=$(echo "$cfile" | sed 's|^\./||')
                  context_dir=$(dirname "$cfile_clean")
                  build_contexts["$context_dir"]="$cfile_clean"
                  echo "Queuing $cfile_clean for manual build."
              done
          else
              echo "Push event triggered incremental build."
              # Determine changed files based on the push event
              if [ "${{ gitea.before }}" = "0000000000000000000000000000000000000000" ]; then
                  # First push to a new branch, list all files
                  CHANGED_FILES=$(git ls-tree -r ${{ gitea.after }} --name-only)
                  echo "This is the first push. All tracked files considered changed."
              else
                  # Compare the commit before and after the push
                  CHANGED_FILES=$(git diff --name-only ${{ gitea.before }} ${{ gitea.after }})
                  echo "Changes detected between ${{ gitea.before }} and ${{ gitea.after }}:"
              fi
              
              echo "Raw changed files: $CHANGED_FILES"

              # Create a list of unique directories affected by changes
              declare -A affected_dirs_set
              for changed_file in $CHANGED_FILES; do
                  dir_to_check=$(dirname "$changed_file")
                  while [[ -n "$dir_to_check" && "$dir_to_check" != "." ]]; do
                      affected_dirs_set["$dir_to_check"]=1
                      dir_to_check=$(dirname "$dir_to_check")
                  done
                  affected_dirs_set["."]=1 # Root dir
              done

              echo "Affected directories: ${!affected_dirs_set[@]}"

              for cfile in $(find . -name Containerfile); do
                  cfile_clean=$(echo "$cfile" | sed 's|^\./||')
                  context_dir=$(dirname "$cfile_clean")
                  
                  if echo "$CHANGED_FILES" | grep -q "^$cfile_clean$"; then
                      build_contexts["$context_dir"]="$cfile_clean"
                      echo "Queuing $cfile_clean because the Containerfile itself changed."
                      continue
                  fi

                  dir_current="$context_dir"
                  while [[ -n "$dir_current" ]]; do
                      if [[ -n "${affected_dirs_set["$dir_current"]}" ]]; then
                          build_contexts["$context_dir"]="$cfile_clean"
                          echo "Queuing $cfile_clean because directory $dir_current is affected."
                          break
                      fi
                      if [[ "$dir_current" == "." ]]; then break; fi
                      dir_current=$(dirname "$dir_current")
                  done
              done
          fi

          if [ ${#build_contexts[@]} -eq 0 ]; then
              echo "No builds required."
              exit 0
          fi

          for context_dir in "${!build_contexts[@]}"; do
              echo "$context_dir"
          done | awk -F/ '{ print NF, $0 }' | sort -n | cut -d' ' -f2- | while read -r sorted_context_dir; do
              cfile_clean=${build_contexts["$sorted_context_dir"]}
              if [ -z "$cfile_clean" ]; then
                  cfile_clean=$(find "$sorted_context_dir" -name Containerfile -print -quit | sed 's|^\./||')
                  if [ -z "$cfile_clean" ]; then
                      echo "Warning: Containerfile not found for context $sorted_context_dir. Skipping."
                      continue
                  fi
              fi

              image_name=""
              image_tag=""

              if [ "$sorted_context_dir" = "." ]; then
                  image_name="$REPO_NAME_LOWER"
                  image_tag="latest"
              else
                  current_dir_name=$(basename "$sorted_context_dir")
                  parent_dir_path=$(dirname "$sorted_context_dir")

                  if [ "$parent_dir_path" = "." ]; then
                      image_name=$(echo "$current_dir_name" | tr '[:upper:]' '[:lower:]')
                      image_tag="latest"
                  else
                      image_name=$(echo "$(basename "$parent_dir_path")" | tr '[:upper:]' '[:lower:]')
                      image_tag=$(echo "$current_dir_name" | tr '[:upper:]' '[:lower:]')
                  fi
              fi
              
              IMAGE_URL="${REGISTRY_BASE}/${image_name}:${image_tag}"
              echo ""
              echo "================================================="
              echo "Found:      $cfile_clean (due to changes in $sorted_context_dir or its Containerfile)"
              echo "Context:    $sorted_context_dir"
              echo "Building:   $IMAGE_URL"
              echo "================================================="
              
              podman build --no-cache -t "$IMAGE_URL" -f "$cfile_clean" "$sorted_context_dir"
              
              echo "Pushing $IMAGE_URL"
              podman push "$IMAGE_URL"
              echo "================================================="
              echo ""
          done
          
          echo "Incremental builds complete."
